import numpy as np
import tensorflow
from typing import List, Any
import sys
import msvcrt

from policies import VAE
from vectors_to_blocks import *

# Only valid/needed for Unix
def getch():
    """ Allows to input values without pressing enter """
    import termios
    import sys
    import tty

    def _getch():
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
    return _getch()

def fitness_VAE(evolved_parameters: np.array, generator_init_params: dict, restricted_flag: bool) -> float:
    """ 
    For an interactive evolution, where each structure is presented to the human.
    Query the fitness of a structure generated by a given policy network, whose parameters are given in argument.
    input:
        evolved_parameters: parameters of a policy network p, element of the population
        generator_init_params: dictionary of parameters given as input of train
        restricted_flag: boolean, tells if work with a restricted number of blocks
    output:
        reward for the network p

    """
    # Unload generator init parameters
    one_hot_dim = generator_init_params['output_dim']
    embedding_dim = generator_init_params['embedding_dim']
    offset = generator_init_params['position']
    oriented = generator_init_params['oriented']
    dimension = generator_init_params['dimension']
    n_layers = generator_init_params['n_layers']
    bounds = generator_init_params['bounds']
    symmetrise = generator_init_params['symmetrise']
    min_size = generator_init_params['min_size']

    # Initilise policy network
    p = VAE
    # Load weights into the policy network

    # Generate structure with MLP
    blocks, orientations, matter_blocks = p.generate_structure(
        generator_init_params)

    if matter_blocks > min_size:

        # Build it in MInecraft
        build_zone(blocks, offset, restricted_flag,
                   orientations, oriented, dimension)
        # Ask Rating Human
        print("Rate the creation from 1 to 5:")
        reward = float(msvcrt.getch())
        print(reward)
        # Clean blocks function afterwards: clean all zone
        clean_zone([neo_bound, bounds[1], bounds[2]], offset)
    else:
        reward = 0
    scaled_reward = float(max(min(reward, 5), 1)*10)
    return scaled_reward  # bound reward from 10 to 50

def fitness_VAE_alltogether(evolved_parameters: np.array, generator_init_params: dict, restricted_flag: bool) -> float:
    """
    For an interactive evolution, with N(=batch_size) structures compared.
    Ask the human to select a structure among N structures generated each by a different policy network.
    input:
        evolved_parameters: np.array of size batch_size * N_policy_param(>>), gathering the parameters of the batch_size policy network compared here.
        generator_init_params: dictionary of parameters given as input of train
        restricted_flag: boolean, tells if work with a restricted number of blocks
    output:
        rewards: list of size batch_size of rewards for each of these networks.

    """
    # Unload generator init parameters
    one_hot_dim = generator_init_params['output_dim']
    embedding_dim = generator_init_params['embedding_dim']
    origin = generator_init_params['position']
    batch_size = generator_init_params['choice_batch']
    bounds = generator_init_params['bounds']
    oriented = generator_init_params['oriented']
    dimension = generator_init_params['dimension']
    population_size = generator_init_params['population_size']
    min_size = generator_init_params['min_size']
    symmetrise = generator_init_params['symmetrise']
    n_layers = generator_init_params['n_layers']
    global_count = 0
    local_count = 0
    # INITIALISATION of some parameters
    blocks_batch = []
    spacing = 7  # spacing between 2 structure
    # If symmetric structure, like if bound[0] get multiplied by 2
    if symmetrise:
        neo_bound = 2*bounds[0]
    else:
        neo_bound = bounds[0]

    width_batch = (neo_bound + spacing) * batch_size
    # so player can see the different creatures
    perspective = np.floor(width_batch/2)
    # print("Position player suggested:", origin)
    rewards = [0]*population_size
    batch_indices = []

    # Loop on the whole structure
    while global_count < population_size:
        while local_count < batch_size and global_count < population_size:
            # Initilise new policy network
            p = MLP(one_hot_dim, embedding_dim, dimension, n_layers)
            # Load weights into the policy network
            nn.utils.vector_to_parameters(torch.tensor(
                evolved_parameters[global_count, :], dtype=torch.float32),  p.parameters())
            # Generate structure with MLP
            blocks, orientations, matter_blocks = p.generate_structure(
                generator_init_params)
            global_count += 1
            if matter_blocks > min_size:  # Then non empty structure, and structure big enough
                blocks_batch.append(blocks)
                local_count += 1
                batch_indices.append(global_count-1)
        # Build in Minecraft these different structures aligned
        # AS now, never rate the last incomplete batch
        if local_count == batch_size:
            offset = [origin[0] -
                      np.floor(width_batch/2), 4, origin[2] - perspective]
            # print("Offset", offset)
            for i in range(len(blocks_batch)):
                build_zone(
                    blocks_batch[i], offset, restricted_flag, orientations, oriented, dimension)
                # redefine first coordinate offset
                offset[0] += neo_bound + spacing
            # Ask Rating Human
            print("Choose one of these structures, from 1 to " +
                  str(batch_size) + " (west to east) ")

            while True:
                print(batch_indices)
                index = int(msvcrt.getch())
                try:

                    if index not in np.arange(len(batch_indices))+1:
                        print('Entry not valid, try again. Press 0 to EXIT')
                    else:
                        break
                except:
                    print('Entry not valid, try again1')
                if index == 0:
                    offset = [
                        origin[0] - np.floor(width_batch/2), 4, origin[2] - perspective]
                    full_bounds = [(neo_bound + spacing) *
                                   batch_size, bounds[1], bounds[2]]
                    clean_zone(full_bounds, offset)
                    sys.exit("Bye")

            # Update rewards of the picked creature
            selected_structure = batch_indices[index-1]
            # structure batch_size (last one) is global_count-1
            rewards[selected_structure] = 50
            # CHECK right structure reward:
            #print("current_indices:", batch_indices)
            #print("selected indices:", selected_structure)
            #print("selected blocks", all_blocks[selected_structure])
            # RESET variables for after and clean zone
            offset = [origin[0] -
                      np.floor(width_batch/2), 4, origin[2] - perspective]
            full_bounds = [(neo_bound + spacing) *
                           batch_size, bounds[1], bounds[2]]
            clean_zone(full_bounds, offset)
            local_count = 0
            blocks_batch = []
            batch_indices = []

    return rewards  # bound reward from 10 to 50 ?




